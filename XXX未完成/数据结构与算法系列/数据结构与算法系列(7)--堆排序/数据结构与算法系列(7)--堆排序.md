# 数据结构与算法系列(7)--堆排序

这一篇文章主要介绍二叉堆的概念，以及堆排序算法

## 二叉堆

二叉堆其实就是由一个数组数据表示出来的一个完全二叉树，树的内容在后序讲述，二叉堆需要满足的仅仅是父节点的值大于两个子节点

为了方便计算，第一个元素默认为在1号位置，当然这个数据可以进行转换

![](http://blog-cdn.chenxiyuan.fun/2019-3-4/02bbf2e0-919d-4292-81e1-4f8ea4d9df78.png)

## 堆排序

堆排序的核心在于将数组构建成一个有序的堆，然后通过提取堆的顶部(最大值)--维护的循环来对堆进行排序

### 构造有序堆

构造有序堆只需要将元素一个个遍历(一个个加入到堆当中)，然后进行`上浮`即可，也就是元素与自己的父元素进行比较，然后如果大于父元素就进行交换，并重复操作直到不满足或者到顶

![](http://blog-cdn.chenxiyuan.fun/2019-3-4/d9a24e89-7aef-402f-9c62-58121ca385a7.png)

### 下沉

在堆构造完成后，就能直接获取最大元素，在获取最大元素后只要将其与堆的末尾元素交换，然后末尾的位置不纳入堆的范围即可，同时使用`下沉`操作，来将置换上来的小值向下交换，维持堆的循序结构

![](http://blog-cdn.chenxiyuan.fun/2019-3-4/1e39cf1b-6f2b-49e8-b777-38f91fac4e73.png)

### 堆排序实现

``` javascript
function StackSort(arr){
    //上浮--默认最后一个是新加的
    function swim(arr, len){
        len++
        while (len > 1 && arr[len - 1] > arr[parseInt(len / 2) - 1]){
            [arr[len - 1], arr[parseInt(len / 2) - 1]] = [arr[parseInt(len / 2) - 1], arr[len - 1]] 
            len = parseInt(len / 2)
        }
    }

    //下沉--将第一个元素下沉
    function sink(arr, len){
        let i = 1 //其实从0映射过来
        len++
        while (true){
            let next
            if (i * 2 <= len && i * 2 + 1 <= len && arr[i * 2 - 1] < arr[i * 2]){
                next = i * 2 + 1
            } else {
                next = i * 2
            }

            if (next <= len && arr[i - 1] < arr[next - 1]){
                [arr[i - 1], arr[next - 1]] = [arr[next - 1], arr[i - 1]]
                i = next
            } else {
                break
            }
        }
    }

    let length = arr.length
    for (let i = 0; i < length; i++){
        swim(arr, i)
    }

    for (let i = length - 1; i > 0; i--){
        [arr[0], arr[i]] = [arr[i], arr[0]]
        sink(arr, i - 1)
    }

    return arr
}
```

除此之外，堆的初始化还可以通过`下沉`来完成

## END

>   2019-03-04   立项