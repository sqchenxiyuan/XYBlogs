# 长连接持续通讯开发方式的思考

这篇文章将讲述我学习JSON-RPC协议和WebSocket长连接后对持续通讯开发方式的思考。文中会简单介绍JSON-RPC，并很简单描述我的看法。

## 序

在平时的开发中，我们大多都依靠应用层进行开发，例如HTTP协议，DNS协议等等，都解决了相应的应用场景，但是在开发自己的应用时，我们顺理成章的依靠这些现有的协议，来快速开发。

这些都是属于网络的请求方式，当然是不能完全解决开发中的需求，所以才有了 `RPC` 协议来屏蔽网络层，构建客户端和服务端之间的联系。

下面简单讲述一下 `JSON-RPC` 协议的内容。

## JSON-RPC

`JSON-RPC` 是一个基于 `JSON` 格式的 `RPC` 协议。具有轻量，解析快的优点。

### 请求结构

其请求结构也与上篇文章 `初识RPC` 中讲述的要求一样，包含协议版本、方法名、参数、请求ID。

1.  协议版本（`jsonrpc`）

    这个字段用于表明JSON-RPC协议的版本号，比如 `2.0`

2.  方法名（`method`）

    这个字段表明请求的方法

3.  参数（`params`）

    调用方法所需要的结构化参数值，该字段可以被省略

4.  请求ID（`id`）

    已建立客户端的唯一标识id，值必须包含一个字符串、数值或NULL空值。

    服务端必须回答相同的值如果包含在响应对象。 这个成员用来两个对象之间的关联上下文。

比如要远程调用一个叫 `getTime` 的函数，发出的请求大概就是这样

``` json

{
    "jsonrpc":"2.0",
    "method":"getTime",
    "id":10
}

```

#### 通知

JSON-RPC 支持通知这一请求方式（不携带id），表明客户端对返回的结果没有兴趣，这时服务端可以不返回相关结果。

### 响应格式

响应的格式只是省略了调用的方法而已，

1.  协议版本（`jsonrpc`）

2.  结果（`result`）

    该字段在成功时必须包含。

3.  错误（`error`）

    该字段在出错时时必须包含。

    错误对象的格式

    1.  错误码（`code`）

        使用数值表示该异常的错误类型

    2.  错误信息（`message`）

        对该错误的简单描述字符串

    3.  附带数据（`data`）

        包含关于错误附加信息的基本类型或结构化类型。该成员可忽略。 该成员值由服务端定义（例如详细的错误信息，嵌套的错误等）。

4.  请求ID（`id`）

    与请求的请求ID是相对应的。用于客户端识别请求。

例如对上面的请求：

成功时：

``` json

{
    "jsonrpc":"2.0",
    "result":"Wed May 31 2017 12:33:46 GMT+0800 (中国标准时间)",
    "id":10
}

```
错误时：
``` json

{
    "jsonrpc":"2.0",
    "error":{
        "code":"-32601",
        "message":"该方法不存在或无效"
    },
    "id":10
}

```

### 批处理调用

JSON-RPC 协议同时也支持批处理调用，就是同时请求多个请求使用同一个网络请求发出

例如:

``` json

[
    {
        "jsonrpc":"2.0",
        "method":"getTime",
        "id":10
    },
    {
        "jsonrpc":"2.0",
        "method":"getTime",
        "id":10
    }
]

```

## 存在的问题

在现在实时消息需求极高的情况下，服务端推送服务基本是必须的，虽然可以使用`长轮询`、`短轮询`、`长连接`的方式实现消息的推送。
### 持续性响应和请求

对于某些持续性相应和请求，比如实时的消息，阶段性的结果（请求的进度等），服务器的监听等等，目前的主流都是采用监听回调的方式来实现，

``` javascript

wsclient.on('event',callback)

```

大多的封装基于 `webSocket` 的 `message` 事件进行分发。无论服务端对响应的监听，还是客户端对请求的监听，现在大多数库都主要采取的事件的形式来实现。

这些库大多都只是对请求的一次封装，对开发方式的改变不大，这样的方式使得开发一应一答的请求方式，变得复杂，致使webSocket依然是持续性通讯的天下，短通讯只能去HTTP之类的请求上进行。在系统开发时，客户端与服务端的通信多样，也会提高复杂性。

使用 `RPC` 协议可以将通信请求的路径全部约束到一个地点，然后由应用内部分发，简化服务器对外请求端口，同时使用 `RPC` 协议可以解决短请求在长连接上处理不便的问题。但是 `RPC` 协议又对处理持续请求存在问题。毕竟是远程调用协议，哪有函数是持续返回数据的=。=

所以如何将 RPC 协议扩展为支持长连接就是现在问题~~~

解决方法暂时没有想出来，=。=大家可以一起讨论

## 后记

这篇文章，实在我编写webSocket封装事，越来越糊涂写下来的，编写一个库果然还是要先写出规范才行啊=、=，

后面我将讲述我构建的一个协议来解决上述问题，并实现一个简单的通讯框架库，然后用一个聊天室作为DEMO

=、=大概一年后吧  哈哈哈哈哈哈

## 参考资料

[JSON-RPC官网](http://json-rpc.org/)

[JSON-RPC 2.0中文翻译](http://wiki.geekdream.com/Specification/json-rpc_2.0.html)

## END

>   2017-5-31   完成

>   2017-5-31   立项
