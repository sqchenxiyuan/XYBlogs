# 函数封装之数组去重

数组去重是编程中十分重要的方法，这篇文章将介绍多个数组去重的方法。

## JS的数组去重

数组去重，顾名思义是要将数组中的重复数值去除，所以数值比对我们都需要使用 `===` 运算符。

然而去重我们还需要一些注意东西:

1. `NaN===NaN` 为 `false`
    在去重时，我们应该是希望 `NaN` 是只保留一个，所以 `NaN` 需要做额外判断。

## 双重循环去重

数组去重一般最先想到的可能就是双循环去重，建立一个新数组，将没有重复的放到新数组中，循环比较。

``` javascript

function unique_2loop(arr){//最简单的双循环去重
  var i,j;
  var result=[];
  var l=arr.length;
  loop1:
  for(i=0;i<l;i++){
    var rl=result.length;

    for(j=0;j<rl;j++){
      if(arr[i]===result[j]||typeof arr[i] ==='number' && typeof result[i] ==='number' && isNaN(arr[i])&&isNaN(result[i])){
        continue loop1;
      }
    }
    result.push(arr[i]);
  }
  return result;
}

```

这样看起来我们可能觉的有点复杂，第二重循环我们用 `indexOf` 可以去掉这样代码更加直观。

``` javascript

function unique_2loop_indexOf(arr){
  var result=[];
  var l=arr.length;
  var haveNaN=false;//标记是否有了NaN

  for(var i=0;i<l;i++){
    var rl=result.length;

    if(result.indexOf(arr[i])===-1||typeof arr[i] ==='number' && isNaN(arr[i]) && !haveNaN){
      if(!haveNaN&&isNaN(data))haveNaN=true;
      result.push(arr[i]);
    }
  }

  return result;
}

```

甚至是

``` javascript

function unique_2loop_indexOf_forEach(arr){
  var result = [];
  var haveNaN=false;//标记是否有了NaN

  arr.forEach((data)=>{
    if(result.indexOf(data)===-1||typeof data ==='number' && isNaN(data) && !haveNaN){
      if(!haveNaN&&isNaN(data))haveNaN=true;
      result.push(data);
    }
  });

  return result;
}

```

但是这些方法，由于采用了双重循环，当处理大数据时耗时特别长，所以只能用来处理一些较小的数组。

## Hash表快速去重

双重循环去重的时间较长，而快速提升去重速度的方法大都是采用构建Hash标识的方式。

比如

``` javascript

function unique_hash(arr){
  var result = [];
  var hashMap={};

  arr.forEach((data)=>{
    if(!hashMap[data]){
      result.push(data);
      hashMap[data]=true;
    }
  });

  return result;
}

```

然后大多都一眼晃过，对啊，这样就可以了，又简洁又高效~

但是你试试这样呢？

``` javascript

var arr=[1,'1','null',null,{x:1},{x:2}];

unique_hash(arr);//[1, "null", {x:1}]

```

然后你会发现，并没有真正的完成去重，因为使用Object为Hash表时键值对中的键必须为 `string`,所以我们必须分数据类型进行。

``` javascript

function unique_hash_type(arr){
  var result = [];
  var hashMap={};

  arr.forEach((data)=>{
    var type=typeof data;
    if(!hashMap[type])hashMap[type]={};
    if(!hashMap[type][data]){
      result.push(data);
      hashMap[type][data]=true;
    }
  });

  return result;
}

var arr=[1,'1','null',null,{x:1},{x:2}];

unique_hash_type(arr);//[1, "1", "null", null, {x:1}]

```

这里我们会发现 `object` 类型的数据并没有正确的处理，因为 `object` 转换为 `string` 类型时，调用的 `toString` 都是获得的 `[object Object]`

同理我们来看 `function` 类型，虽然`function` 类型转化为 `string` 类型时，它展示的是源码，但是它的字符串过长，在比对时将会消耗大量时间，因为 `function` 类型的根源依然是 `object` 类型，所以我们可以将 `function` 类型当作 `object` 类型一同处理。

### Hash表Object对象的处理

由于在JS不能获取Object对象的引用的特征，我们只能在Object对象的身上开刀，我们可以尝试在Object对象上进行标记来实现目的，然后在完成后去除标记即可。

``` javascript

function unique_hash_type_sign(arr){
  var result = [];
  var hashMap={
    'object':[],
    'object_sign':[],
    'boolean':{},
    'string':{},
    'null':{},
    'undefined':{},
    'number':{}
  };
  var sign;//标记

  arr.forEach((data)=>{
    var type=typeof data;
    if(type === 'object' || type === 'function'){
      sign="__sign__";//标记的键值
      while(true){
        if(data[str] === undefined){
          hash.object.push(data);
          object_sign.push(str);
          data[str]=data;
          out.push(data);
          break;
        }else{
          if(item[str]===item){
            return;//存在重复的
          }else{//冲突避免
            str+='_';
            continue;
          }
        }
      }
    }else{
      if(!hashMap[type][data]){
        result.push(data);
        hashMap[type][data]=true;
      }
    }
  });

  while(true){
    var obj=hashMap.object.pop();
    if(!obj){
      break;
    }
    var str=hashMap.object_sign.pop();
    delete obj[str];
  }

  return result;
}

var arr=[1,'1','null',null,{x:1},{x:2}];

unique_hash_type(arr);//[1, "1", "null", null, {x:1}]

```

## END

> 2017-2-20 立项
